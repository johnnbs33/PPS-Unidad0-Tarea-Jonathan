{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tarea Unidad 0 - RA5 DevSecOps b\u00e1sico y automatizaci\u00f3n de la documentaci\u00f3n. Objetivos Esta actividad tiene como objetivo poner en pr\u00e1ctica los contenidos tratados en esta unidad: Lenguaje de marcas Markdown Sistemas de control de versiones: Git Creaci\u00f3n y administraci\u00f3n de contenedores: Docker Ciclos de desarrollo de software seguros: DevSecOps Documentaci\u00f3n Enlaces Operaciones con Git. Operaciones con GitHub Actions. GitHub Pages. Docker. Conclusiones. Autor: Jonathan Barbero S\u00e1nchez Curso de especializaci\u00f3n en Ciberseguridad en entornos de las Tecnolog\u00edas de la Informaci\u00f3n","title":"Home"},{"location":"#tarea-unidad-0-ra5","text":"DevSecOps b\u00e1sico y automatizaci\u00f3n de la documentaci\u00f3n.","title":"Tarea Unidad 0 - RA5"},{"location":"#objetivos","text":"Esta actividad tiene como objetivo poner en pr\u00e1ctica los contenidos tratados en esta unidad: Lenguaje de marcas Markdown Sistemas de control de versiones: Git Creaci\u00f3n y administraci\u00f3n de contenedores: Docker Ciclos de desarrollo de software seguros: DevSecOps Documentaci\u00f3n","title":"Objetivos"},{"location":"#enlaces","text":"Operaciones con Git. Operaciones con GitHub Actions. GitHub Pages. Docker. Conclusiones. Autor: Jonathan Barbero S\u00e1nchez Curso de especializaci\u00f3n en Ciberseguridad en entornos de las Tecnolog\u00edas de la Informaci\u00f3n","title":"Enlaces"},{"location":"conclusiones/","text":"Conclusiones. En la puesta en marcha de los repositorios, hay que tener claro cu\u00e1ndo se trabaja en local o en remoto , as\u00ed como la rama en la que se est\u00e1 trabajando en el momento. Al realizar un push de los cambios, es necesario haber hecho previamente un commit de los mismos. \u201cLa documentaci\u00f3n generada mediante Markdown nos facilita visualizarla de manera r\u00e1pida y limpia . Con GitHUb Actions , realizaremos flujos de trabajo , en respuesta a los eventos del repositorio. Con MkDocs , documentaremos de forma autom\u00e1tica los ficheros .md a trav\u00e9s de GitHub Pages de forma f\u00e1cil, sin intervenci\u00f3n manual. Con Docker , podremos levantar un servicio de forma r\u00e1pida y sencilla , con multitud de opciones. Tareas realizadas en orden. Creaci\u00f3n del repositorio . Repositorio local . Conexi\u00f3n con GitHub . Repositorio remoto en GitHub. Creaci\u00f3n del fichero MkDocs . Creaci\u00f3n del Workflow . Fichero CreacionDocumentacion.yml Creaci\u00f3n de todos los ficheros Markdown ( .md ). Push al repositorio en GitHub. Configuraci\u00f3n de GitHub Pages . Despliegue de Docker . Fichero docker-compose.yml Ultimas modificaciones y ajustes de los ficheros Markdown. Resumen r\u00e1pido de los principales ficheros. Fichero Cometido CreacionDocumentacion.yml Establecer el workflow mkdocs.yml Configuraci\u00f3n de MkDocs docker-compose.yml Orquestaci\u00f3n de contenedores Docker","title":"Conclusiones"},{"location":"conclusiones/#conclusiones","text":"En la puesta en marcha de los repositorios, hay que tener claro cu\u00e1ndo se trabaja en local o en remoto , as\u00ed como la rama en la que se est\u00e1 trabajando en el momento. Al realizar un push de los cambios, es necesario haber hecho previamente un commit de los mismos. \u201cLa documentaci\u00f3n generada mediante Markdown nos facilita visualizarla de manera r\u00e1pida y limpia . Con GitHUb Actions , realizaremos flujos de trabajo , en respuesta a los eventos del repositorio. Con MkDocs , documentaremos de forma autom\u00e1tica los ficheros .md a trav\u00e9s de GitHub Pages de forma f\u00e1cil, sin intervenci\u00f3n manual. Con Docker , podremos levantar un servicio de forma r\u00e1pida y sencilla , con multitud de opciones.","title":"Conclusiones."},{"location":"conclusiones/#tareas-realizadas-en-orden","text":"Creaci\u00f3n del repositorio . Repositorio local . Conexi\u00f3n con GitHub . Repositorio remoto en GitHub. Creaci\u00f3n del fichero MkDocs . Creaci\u00f3n del Workflow . Fichero CreacionDocumentacion.yml Creaci\u00f3n de todos los ficheros Markdown ( .md ). Push al repositorio en GitHub. Configuraci\u00f3n de GitHub Pages . Despliegue de Docker . Fichero docker-compose.yml Ultimas modificaciones y ajustes de los ficheros Markdown.","title":"Tareas realizadas en orden."},{"location":"conclusiones/#resumen-rapido-de-los-principales-ficheros","text":"Fichero Cometido CreacionDocumentacion.yml Establecer el workflow mkdocs.yml Configuraci\u00f3n de MkDocs docker-compose.yml Orquestaci\u00f3n de contenedores Docker","title":"Resumen r\u00e1pido de los principales ficheros."},{"location":"docker/","text":"Docker. Preparaci\u00f3n del del repositorio. Creaci\u00f3n del entorno Docker. Rama gh-pages. Iniciando el entorno Preparaci\u00f3n del repositorio. Cambiaremos a la rama gh-pages en local, a partir de la remota de GitHub . git checkout gh-pages Una vez terminado todo el ejercicio de Docker, si quisieramos volver a la rama main , ejecutariamos el comando siguiente: git checkout main Si realizamos algun cambio en alguna de las p\u00e1ginas MarkDown , tendremos que traer los ultimos cambios de la rama gh-pages , que habran sido generados por MkDocs . git pull Creaci\u00f3n del entorno Docker. Orquestaremos un servicio web con un \u00fanico archivo docker-compose.yml . Nos situaremos fuera del directorio del repositorio, crearemos un directorio llamado PPS-Unidad0-Tarea-Jonathan-Docker . mkdir PPS-Unidad0-Tarea-Jonathan-Docker Situados dentro de \u00e9l, crearemos el fichero docker-compose.yml . nano docker-compose.yml A\u00f1adimos el siguiente contenido. services: web: image: nginx:stable container_name: PPSUnidad0-Tarea_Jonathan ports: - \"8085:80\" volumes: - /home/ppsjonathan/Documentos/PPS/PPS-Unidad0-Tarea-Jonathan:/usr/share/nginx/html Pulsamos Ctrl + O para guardar los cambios y Ctrl + X para salir del editor nano . Resumen de las operaciones del fichero Compose: El servicio se llamara web . Se crear\u00e1 a partir de la imagen de nginx estable . El nombre del contenedor ser\u00e1 PPSUnidad0-Tarea_Jonathan . Mapearemos el puerto 8085 del host al 80 del servidor web nginx. Definimos bind mount del directorio que aloja los ficheros est\u00e1ticos del repositorio, hacia el directorio donde nginx busca los archivos web. Tips de la rama gh-pages. Para mantener actualizada la rama gh-pages local, que es generada autom\u00e1ticamente por GitHub Actions , el proceso es un poco diferente a un git pull normal, ya que esa rama suele ser reescrita por la acci\u00f3n . Pero existe una forma de hacerlo, que es forzar la rama local para que sea un espejo exacto de la rama remota . Traemos los cambios del repositorio remoto. git fetch origin Nos situamos en la rama gh-pages . git switch gh-pages Dado que las GitHub Actions suelen reescribir el historial de gh-pages , forzamos la actualizaci\u00f3n para hacer que la rama local sea exactamente igual a la remota. git reset --hard origin/gh-pages Los argumentos del comando ( reset --hard ) descarta todos los cambios que no est\u00e9n \"commiteados\" en la rama en la que nos encontramos. Sin embargo, como la rama gh-pages es auto-generada, nunca deberiamos de tener cambios locales en ella, por lo que este comando es seguro en este contexto. Inicializando el entorno. A contiunaci\u00f3n, crearemos y levantaremos los servicios definidos en el archivo docker-compose.yml en modo detached (segundo plano). docker compose up -d En la terminal, observaremos como se levantan los servicios, haciendo pull de las imagenes si no estuvieran ya. - Comprobamos que todo esta funcionando, mediante el siguiente comando: docker compose ps La salida nos mostrar\u00e1 los servicios en ejecuci\u00f3n, en este caso es solamente uno, y podremos observar el nombre, estado, puertos, entre otros datos. - Tambi\u00e9n podemos realizar un inspect del contenedor para visualizar toda la informaci\u00f3n del mismo. docker inspect PPSUnidad0-Tarea_Jonathan","title":"Docker"},{"location":"docker/#docker","text":"Preparaci\u00f3n del del repositorio. Creaci\u00f3n del entorno Docker. Rama gh-pages. Iniciando el entorno","title":"Docker."},{"location":"docker/#preparacion-del-repositorio","text":"Cambiaremos a la rama gh-pages en local, a partir de la remota de GitHub . git checkout gh-pages Una vez terminado todo el ejercicio de Docker, si quisieramos volver a la rama main , ejecutariamos el comando siguiente: git checkout main Si realizamos algun cambio en alguna de las p\u00e1ginas MarkDown , tendremos que traer los ultimos cambios de la rama gh-pages , que habran sido generados por MkDocs . git pull","title":"Preparaci\u00f3n del repositorio."},{"location":"docker/#creacion-del-entorno-docker","text":"Orquestaremos un servicio web con un \u00fanico archivo docker-compose.yml . Nos situaremos fuera del directorio del repositorio, crearemos un directorio llamado PPS-Unidad0-Tarea-Jonathan-Docker . mkdir PPS-Unidad0-Tarea-Jonathan-Docker Situados dentro de \u00e9l, crearemos el fichero docker-compose.yml . nano docker-compose.yml A\u00f1adimos el siguiente contenido. services: web: image: nginx:stable container_name: PPSUnidad0-Tarea_Jonathan ports: - \"8085:80\" volumes: - /home/ppsjonathan/Documentos/PPS/PPS-Unidad0-Tarea-Jonathan:/usr/share/nginx/html Pulsamos Ctrl + O para guardar los cambios y Ctrl + X para salir del editor nano . Resumen de las operaciones del fichero Compose: El servicio se llamara web . Se crear\u00e1 a partir de la imagen de nginx estable . El nombre del contenedor ser\u00e1 PPSUnidad0-Tarea_Jonathan . Mapearemos el puerto 8085 del host al 80 del servidor web nginx. Definimos bind mount del directorio que aloja los ficheros est\u00e1ticos del repositorio, hacia el directorio donde nginx busca los archivos web.","title":"Creaci\u00f3n del entorno Docker."},{"location":"docker/#tips-de-la-rama-gh-pages","text":"Para mantener actualizada la rama gh-pages local, que es generada autom\u00e1ticamente por GitHub Actions , el proceso es un poco diferente a un git pull normal, ya que esa rama suele ser reescrita por la acci\u00f3n . Pero existe una forma de hacerlo, que es forzar la rama local para que sea un espejo exacto de la rama remota . Traemos los cambios del repositorio remoto. git fetch origin Nos situamos en la rama gh-pages . git switch gh-pages Dado que las GitHub Actions suelen reescribir el historial de gh-pages , forzamos la actualizaci\u00f3n para hacer que la rama local sea exactamente igual a la remota. git reset --hard origin/gh-pages Los argumentos del comando ( reset --hard ) descarta todos los cambios que no est\u00e9n \"commiteados\" en la rama en la que nos encontramos. Sin embargo, como la rama gh-pages es auto-generada, nunca deberiamos de tener cambios locales en ella, por lo que este comando es seguro en este contexto.","title":"Tips de la rama gh-pages."},{"location":"docker/#inicializando-el-entorno","text":"A contiunaci\u00f3n, crearemos y levantaremos los servicios definidos en el archivo docker-compose.yml en modo detached (segundo plano). docker compose up -d En la terminal, observaremos como se levantan los servicios, haciendo pull de las imagenes si no estuvieran ya. - Comprobamos que todo esta funcionando, mediante el siguiente comando: docker compose ps La salida nos mostrar\u00e1 los servicios en ejecuci\u00f3n, en este caso es solamente uno, y podremos observar el nombre, estado, puertos, entre otros datos. - Tambi\u00e9n podemos realizar un inspect del contenedor para visualizar toda la informaci\u00f3n del mismo. docker inspect PPSUnidad0-Tarea_Jonathan","title":"Inicializando el entorno."},{"location":"git/","text":"Operaciones con Git Conexi\u00f3n con GitHub. Preparacion del proyecto y creaci\u00f3n del repositorio local. Fichero mkdocs.yml. Subiendo el repositorio a GitHub. Conexi\u00f3n con GitHub. Todas las operaciones de creaci\u00f3n del repositorio en GitHub se realizar\u00e1n a trav\u00e9s de la terminal. En primer lugar, realizaremos una instalacion de las dependencias necesarias para trabajar con git y GitHub . sudo apt update && sudo apt install git gh Realizamos una autenticaci\u00f3n en GitHub . gh auth login Preparaci\u00f3n del proyecto. Crearemos un directorio de trabajo e incluimos el contenido inicial. mkdir PPS-Unidad0-Tarea-Jonathan Inicializamos el repositorio y configuramos la rama principal en main . git config --global init.defaultBranch main git init Fichero mkdocs. Creamos un fichero llamado mkdocs.yml . nano mkdocs.yml En el cual, incluiremos la siguientes l\u00edneas. # mkdocs.yml # Inicializando fichero mkdocs.yml site_name: Tarea Unidad 0 - RA5 site_description: 'Documentaci\u00f3n de la Tarea Unidad 0 - RA5 sobre Git, Docker y CI/CD.' site_author: 'Jonathan Barbero S\u00e1nchez' # Estructura de navegaci\u00f3n nav: - Home: index.md - Git: git.md - GitHub Actions: gitActions.md - GitPages: gitPages.md - Docker: docker.md - Conclusiones: conclusiones.md # Directorios doc_dir: docs # Fin del fichero makdocs.yml Pulsamos Ctrl + O para guardar los cambios y Ctrl + X para salir del editor nano . Subiendo el repositorio a GitHub. Creamos el primer comit con toda la estructura. git add . git commit -am \"Inicializando repositorio\" git branch -M main A continuaci\u00f3n, crearemos el repositorio en GitHub. gh repo create johnnbs33/PPS-Unidad0-Tarea-Jonathan --public --source=. --remote=origin --push","title":"Git"},{"location":"git/#operaciones-con-git","text":"Conexi\u00f3n con GitHub. Preparacion del proyecto y creaci\u00f3n del repositorio local. Fichero mkdocs.yml. Subiendo el repositorio a GitHub.","title":"Operaciones con Git"},{"location":"git/#conexion-con-github","text":"Todas las operaciones de creaci\u00f3n del repositorio en GitHub se realizar\u00e1n a trav\u00e9s de la terminal. En primer lugar, realizaremos una instalacion de las dependencias necesarias para trabajar con git y GitHub . sudo apt update && sudo apt install git gh Realizamos una autenticaci\u00f3n en GitHub . gh auth login","title":"Conexi\u00f3n con GitHub."},{"location":"git/#preparacion-del-proyecto","text":"Crearemos un directorio de trabajo e incluimos el contenido inicial. mkdir PPS-Unidad0-Tarea-Jonathan Inicializamos el repositorio y configuramos la rama principal en main . git config --global init.defaultBranch main git init","title":"Preparaci\u00f3n del proyecto."},{"location":"git/#fichero-mkdocs","text":"Creamos un fichero llamado mkdocs.yml . nano mkdocs.yml En el cual, incluiremos la siguientes l\u00edneas. # mkdocs.yml # Inicializando fichero mkdocs.yml site_name: Tarea Unidad 0 - RA5 site_description: 'Documentaci\u00f3n de la Tarea Unidad 0 - RA5 sobre Git, Docker y CI/CD.' site_author: 'Jonathan Barbero S\u00e1nchez' # Estructura de navegaci\u00f3n nav: - Home: index.md - Git: git.md - GitHub Actions: gitActions.md - GitPages: gitPages.md - Docker: docker.md - Conclusiones: conclusiones.md # Directorios doc_dir: docs # Fin del fichero makdocs.yml Pulsamos Ctrl + O para guardar los cambios y Ctrl + X para salir del editor nano .","title":"Fichero mkdocs."},{"location":"git/#subiendo-el-repositorio-a-github","text":"Creamos el primer comit con toda la estructura. git add . git commit -am \"Inicializando repositorio\" git branch -M main A continuaci\u00f3n, crearemos el repositorio en GitHub. gh repo create johnnbs33/PPS-Unidad0-Tarea-Jonathan --public --source=. --remote=origin --push","title":"Subiendo el repositorio a GitHub."},{"location":"gitActions/","text":"Operaciones con GitHub Actions. Creaci\u00f3n de WorkFlow. Prepara los cambios y subida a GitHub Creaci\u00f3n de Workflow. Dentro del directorio .github/workflows tendremos el fichero CreacionDocumentacion.yml , en \u00e9l debemos de establecer el workflow que se disparar\u00e1 con cada push , para gestionar el despliegue de MkDocs . Editamos el fichero: nano .github/workflows/CreacionDocumentacion.yml E incluiremos las siguientes l\u00edneas. # CreacionDocumentacion.yml # Configuraci\u00f3n del WorkFlow name: Deploy MkDocs Tarea 0 on: push: branches: - main # Permisos permissions: contents: write pages: write id-token: write # Definici\u00f3n del trabajo jobs: deploy: runs-on: ubuntu-latest steps: # Paso 1: Obtenci\u00f3n del c\u00f3digo fuente - name: Checkout Repo uses: actions/checkout@v3 # Paso 2: Configuraci\u00f3n de Python - name: Set up Python uses: actions/setup-python@v4 with: python-version: '3.x' # Paso 3: Instalar dependencias - name: Install dependencies run: pip install mkdocs # Paso 4: Construir y desplegar la documentaci\u00f3n - name: Deploy docs run: mkdocs gh-deploy --force env: GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Fin del fichero CreacionDocumentacion.yml Pulsamos Ctrl + O para guardar los cambios y Ctrl + X para salir del editor nano . Subiendo los ficheros a GitHub. Una vez guardado el fichero, preparamos los cambios, realizamos un commit y lo subimos a GitHub . git add . git commit -m \"Modificaci\u00f3n de CreacionDocumentacion.yml\" git push","title":"GitHub Actions"},{"location":"gitActions/#operaciones-con-github-actions","text":"Creaci\u00f3n de WorkFlow. Prepara los cambios y subida a GitHub","title":"Operaciones con GitHub Actions."},{"location":"gitActions/#creacion-de-workflow","text":"Dentro del directorio .github/workflows tendremos el fichero CreacionDocumentacion.yml , en \u00e9l debemos de establecer el workflow que se disparar\u00e1 con cada push , para gestionar el despliegue de MkDocs . Editamos el fichero: nano .github/workflows/CreacionDocumentacion.yml E incluiremos las siguientes l\u00edneas. # CreacionDocumentacion.yml # Configuraci\u00f3n del WorkFlow name: Deploy MkDocs Tarea 0 on: push: branches: - main # Permisos permissions: contents: write pages: write id-token: write # Definici\u00f3n del trabajo jobs: deploy: runs-on: ubuntu-latest steps: # Paso 1: Obtenci\u00f3n del c\u00f3digo fuente - name: Checkout Repo uses: actions/checkout@v3 # Paso 2: Configuraci\u00f3n de Python - name: Set up Python uses: actions/setup-python@v4 with: python-version: '3.x' # Paso 3: Instalar dependencias - name: Install dependencies run: pip install mkdocs # Paso 4: Construir y desplegar la documentaci\u00f3n - name: Deploy docs run: mkdocs gh-deploy --force env: GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Fin del fichero CreacionDocumentacion.yml Pulsamos Ctrl + O para guardar los cambios y Ctrl + X para salir del editor nano .","title":"Creaci\u00f3n de Workflow."},{"location":"gitActions/#subiendo-los-ficheros-a-github","text":"Una vez guardado el fichero, preparamos los cambios, realizamos un commit y lo subimos a GitHub . git add . git commit -m \"Modificaci\u00f3n de CreacionDocumentacion.yml\" git push","title":"Subiendo los ficheros a GitHub."},{"location":"gitPages/","text":"Vinculaci\u00f3n con GitHub Pages. GitHub Pages. URL de GitHub Pages GitHub Pages. Una vez que la pipeline se complete, configuraremos GitHub Pages para que sirva la rama gh-pages . Para ello nos posicionamos en el repositorio. Settings -> Pages . Seleccionamos la rama en Branch y pulsamos en Save . URL de GitHub Pages. La documentaci\u00f3n estar\u00e1 accesible en la URL de GitHub Pages. Nos situamos en el repositorio en GitHub . En la parte derecha, tendremos el enlace a Deployments . Nos abrir\u00e1 una pagina, y debajo de github-pages deployments tendremos la URL de github-pages. URL del despliegue: https://johnnbs33.github.io/PPS-Unidad0-Tarea-Jonathan/","title":"GitPages"},{"location":"gitPages/#vinculacion-con-github-pages","text":"GitHub Pages. URL de GitHub Pages","title":"Vinculaci\u00f3n con GitHub Pages."},{"location":"gitPages/#github-pages","text":"Una vez que la pipeline se complete, configuraremos GitHub Pages para que sirva la rama gh-pages . Para ello nos posicionamos en el repositorio. Settings -> Pages . Seleccionamos la rama en Branch y pulsamos en Save .","title":"GitHub Pages."},{"location":"gitPages/#url-de-github-pages","text":"La documentaci\u00f3n estar\u00e1 accesible en la URL de GitHub Pages. Nos situamos en el repositorio en GitHub . En la parte derecha, tendremos el enlace a Deployments . Nos abrir\u00e1 una pagina, y debajo de github-pages deployments tendremos la URL de github-pages. URL del despliegue: https://johnnbs33.github.io/PPS-Unidad0-Tarea-Jonathan/","title":"URL de GitHub Pages."}]}